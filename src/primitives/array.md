# Масиви и отрязъци

Масивът е колекция от обекти от същия тип `T`, съхранени в съседна памет.
Масивите се създават с помощта на скобите `[]`, и тяхната дължина, която е известна по време на компилация, е част от техния типов подпис `[T; дължина]`.

Отрязъците са подобни на масивите, но тяхната дължина не се знае по време на компилация.
Вместо това отрязъкът е обект от две думи; първата дума е указател към данните,
втората дума е дължината на отрязъка. Размерът на думата е същият като `usize`,
определен от архитектурата на процесора, например 64 бита на x86-64. Отрязъците
могат да бъдат използвани, за да заемат част от масив и имат типов подпис `&[T]`.

```rust,editable,ignore,mdbook-runnable
use std::mem;

// Тази функция достъпва отрязък.
fn analyze_slice(slice: &[i32]) {
    println!("First element of the slice: {}", slice[0]);
    println!("The slice has {} elements", slice.len());
}

fn main() {
    // Масив с фиксиран размер (типовият подпис е излишен).
    let xs: [i32; 5] = [1, 2, 3, 4, 5];
    let xs = [1, 2, 3, 4, 5];

    // Всички елементи могат да бъдат инициализирани със една и съща стойност.
    let ys: [i32; 500] = [0; 500];

    // Индексирането стартира от 0.
    println!("First element of the array: {}", xs[0]);
    println!("Second element of the array: {}", xs[1]);

    // функцията `len` връща броя на елементите в масива.
    println!("Number of elements in array: {}", xs.len());

    // Масивите се разпределят в стека.
    println!("Array occupies {} bytes", mem::size_of_val(&xs));

    // Масивите автоматично могат да бъдат достъпвани като отрязъците.
    println!("Borrow the whole array as a slice.");
    analyze_slice(&xs);

    // Отрязък може да сочи към парче от масив.
    // Те са във форма на [стартиращ_индекс..завършващ_индекс].
    // `стартиращ_индекс` е първата позиция на отрязъка.
    // `завършващ_индекс` е последната позицив+1 на отрязъка.
    println!("Borrow a section of the array as a slice.");
    analyze_slice(&ys[1 .. 4]);

    // Пример за празен отрязък `&[]`:
    let empty_array: [u32; 0] = [];
    assert_eq!(&empty_array, &[]);
    assert_eq!(&empty_array, &[][..]); // Същото, но по-подробно

    // Масивите могат да бъдат достъпни безопасно чрез `.get`, което връща тип `Option`. 
    // Това може да бъде съпоставено както е показано по-долу, или да се използва с `.expect()`,
    // ако желаете програмата да излезе с приятно съобщение, вместо да
    // продължава да се изпълнява.
    for i in 0..xs.len() + 1 { // Опа, с един елемент прекалено напред!
        match xs.get(i) {
            Some(xval) => println!("{}: {}", i, xval),
            None => println!("Slow down! {} is too far!", i),
        }
    }

    // Индексирането извън границите на масива предизвиква грешка по време на компилация.
    //println!("{}", xs[5]);
    // Индексирането извън границите на масива при отрязък предизвиква грешка по време на изпълнение.
    //println!("{}", xs[..][5]);
}
```
