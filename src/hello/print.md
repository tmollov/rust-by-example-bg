# Форматиране на изход

Извеждането се осъществява чрез серия от [`макроси`][macros] дефинирани в модула
[`std::fmt`][fmt], като някои от тях включват:

* `format!`: записва форматиран текст в [String][string].
* `print!`: същото като `format!`, но текстът се извежда на конзолата (io::stdout).
* `println!`: същото като `print!`, но се добавя нов ред.
* `eprint!`: същото като `print!`, но текстът се извежда в стандартния изход за грешки (io::stderr).
* `eprintln!`: същото като eprint!, но се добавя нов ред.

Всички те парсират текста по същия начин.
Освен това, Rust проверява коректността на форматирането по време на компилацията.

```rust,editable,ignore,mdbook-runnable
fn main() {
    // В общия случай, {} ще бъде автоматично заменено със съответните
    // аргументи. Те ще бъдат конвертирани в низове (stringified).
    println!("{} days", 31);

    // Могат да се използват позиционни аргументи. 
    // Указването на цяло число вътре в {} определя кой допълнителен аргумент ще бъде заместен.
    // Аргументите започват от 0 незабавно след форматния низ.
    // в случая 0 = "Alice" и 1 = "Bob"
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");

    // Също така могат да се използват наименовани аргументи.
    println!("{subject} {verb} {object}",
             object="the lazy dog",
             subject="the quick brown fox",
             verb="jumps over");

    // Различно форматиране може да бъде извикано чрез указване на знак за формат след :
    println!("Base 10:               {}",   69420); // 69420
    println!("Base 2 (binary):       {:b}", 69420); // 10000111100101100
    println!("Base 8 (octal):        {:o}", 69420); // 207454
    println!("Base 16 (hexadecimal): {:x}", 69420); // 10f2c
    println!("Base 16 (hexadecimal): {:X}", 69420); // 10F2C

    // Можете да изравнявате текст отдясно с определена ширина.  
    // Това ще изведе "    1". (Четири бели интервала и "1", за обща ширина от 5.)
    println!("{number:>5}", number=1);

    // Можете да допълвате числата с допълнителни нули.
    println!("{number:0>5}", number=1); // 00001
    // също така и със букви
    println!("{number:A>5}", number=1); // AAAA1
    // и да настройвате изравняването отляво, като обръщате знака. Това ще изведе "10000".
    println!("{number:0<5}", number=1); // 10000

    // Можете да използвате именовани аргументи във форматния спецификатор, като добавите `$`.
    println!("{number:0>width$}", number=1, width=5);

    // Rust дори проверява, за да се увери, че са използвани правилният брой аргументи.
    println!("My name is {0}, {1} {0}", "Bond");
    // ЗАДАЧА ^ Добавете липсващия аргумент: "James"

    // Само типове, които имплементират fmt::Display, могат да бъдат форматирани с {}. 
    // Потребителски дефинирани типове по подразбиране не имплементират fmt::Display.

    #[allow(dead_code)] // деактивиране на `dead_code`, който предупреждава за неползван код в модула
    struct Structure(i32);

    // Това няма да компилира, защото Structure не имплементира fmt::Display.
    // println!("This struct `{}` won't print...", Structure(3));
    // TODO ^ Опитайте да премахнете коментара на този ред.

    // За Rust 1.58 и по-нови версии, можете директно 
    // да засечете аргумента от глобалните/локалните променливи. 
    // Точно както по-горе, това ще изведе
    // "    1", 4 бели интервала и "1".
    let number: f64 = 1.0;
    let width: usize = 5;
    println!("{number:>width$}");
}
```

[`std::fmt`][fmt] съдържа много видове [`trait-ове`][traits], които управляват извеждането на текст.
Основната форма на два важни от тях са изброени по-долу:

* `fmt::Debug`: Използва маркера `{:?}`. Форматира текста за цели при дебъгване и отстраняване на грешки.
* `fmt::Display`: Използва маркера {}. Форматира текста по-елегантно и потребителски удобно.

Тук ние използвахме `fmt::Display`, защото стандартната библиотека предоставя имплементации за тези типове.
За да извеждате текст за потребителски типове, се изискват допълнителни стъпки.

Имплементирането на trait-а `fmt::Display` автоматично имплементира
[`ToString`] trait-а, което ни позволява да [конвертираме] дадения тип към [`String`][string].

На *ред 43*, `#[allow(dead_code)]` е [атрибут], който се отнася само до модула след него.

### Дейности

* Коригирайте проблема в горния код (погледнете ЗАДАЧА-та в 55 ред) така че да работи без грешка.
* Опитайте да премахнете коментара на реда, който се опитва да форматира структурата `Structure` (вижте TODO).
* Добавете `println!`, което трябва да принтира: `Pi is roughly 3.142` като контролирате броя на показаните десетични знаци. За целите на това упражнение, използвайте
`let pi = 3.141592` като приблизителна стойност на числото π. (Съвет:може да бъде необходимо да проверите [документацията на `std::fmt`][fmt] за настройване на броя десетични знаци за извеждане.)

### Вижте също

[`std::fmt`][fmt], [`macros`][macros], [`struct`][structs], [`traits`][traits], и [`dead_code`][dead_code]

[fmt]: https://doc.rust-lang.org/std/fmt/
[macros]: ../macros.md
[string]: ../std/str.md
[structs]: ../custom_types/structs.md
[traits]: https://doc.rust-lang.org/std/fmt/#formatting-traits
[`ToString`]: https://doc.rust-lang.org/std/string/trait.ToString.html
[конвертираме]: ../conversion/string.md
[атрибут]: ../attribute.md
[dead_code]: ../attribute/unused.md
