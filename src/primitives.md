# Примитивни типове

Rust предоставя достъп до разнообразни `примитивни типове`. Един пример включва:

### Скаларни типове

* Цели числа със знак: `i8`, `i16`, `i32`, `i64`, `i128` и `isize` (pointer size)
* Цели числа без знак: `u8`, `u16`, `u32`, `u64`, `u128` и `usize` (pointer size)
* Числа с плаваща запетая: `f32`, `f64`
* `char` Unicode скаларни стойности като `'a'`, `'α'` и `'∞'` (4 байта всеки)
* `bool`, което е или `true`, или `false`
* Типът "unit" `()`, чиято единствена възможна стойност е празен `tuple`: `()`

Въпреки че стойността на типа "unit" е `tuple`, той не се счита за съставен тип, защото не съдържа множество стойности.

### Съставни типове

* Масиви - `[1, 2, 3]`
* Tuples -  `(1, true)`

Променливите винаги могат да бъдат *анотирани с тип*.
Числата могат да бъдат анотирани със *суфикс*.
Целите числа имат `i32` анотация по подразбиране, а тези с плаваща запетая `f64`.
Имайте предвид, че Rust може също да извежда типове от контекста.

```rust,editable,ignore,mdbook-runnable
fn main() {
    // Променливите могат да бъдат анотирани по тип.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Обикновенна анотация
    let an_integer   = 5i32; // Суфиксна анотация

    // Или ще се използва тези по подразбиране.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // Типът може да бъде изведен и от контекста.
    let mut inferred_type = 12; // Типа i64 се извежда от друг ред.
    inferred_type = 4294967296i64;

    // Стойността на мутираща променлива може да бъде променена.
    let mut mutable = 12; // Мутираща `i32`
    mutable = 21;

    // Грешка! Типът на променливата не може да бъде променена.
    mutable = true;

    // Променливите могат да бъдат презаписани със `shadowing` т.е. редефиниране.
    let mutable = true;
}
```

### Вижте също

[the `std` library][std], [`mut`][mut], [`inference`][inference], и
[`shadowing`][shadowing]

[std]: https://doc.rust-lang.org/std/
[mut]: variable_bindings/mut.md
[inference]: types/inference.md
[shadowing]: variable_bindings/scope.md
